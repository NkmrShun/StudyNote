# SQL优化 #
1. 选择最有效率的表名顺序
	数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理
	在FROM子句中包含多个表的情况下：
	- 如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推
	- 也就是说：选择记录条数最少的表放在最后
	如果有3个以上的表连接查询：
	- 如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。
	- 也就是说：被其他表所引用的表放在最后

2. WHERE子句中的连接顺序
	数据库采用**自右而左**的顺序解析WHERE子句,根据这个原理,**表之间的连接**必须写在其他WHERE条件之**左**,那些可以过**滤掉最大数量记录的条件**必须写在WHERE子句的之右。

3. SELECT子句中避免使用*号
	- “*”通过查询数据字典完成的，这意味着将耗费更多的时间
	- 使用*号写出来的SQL语句也不够直观。

4. 用TRUNCATE替代DELETE
	删除表全部内容而不改变表结构的时候使用TRUNCATE
	DELETE是一条一条记录的删除，而Truncate是将整个表删除，保留表结构，这样比DELETE快

5. 多使用内部函数提高SQL效率
	例如使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。

6. 使用表或列的别名
	如果表或列的名称太长了，使用一些简短的别名也能稍微提高一些SQL的性能。毕竟要扫描的字符长度就变少了。。。

7. 多使用commit
	comiit会释放回滚点…

8. 善用索引
	索引就是为了提高我们的查询数据的，当表的记录量非常大的时候，我们就可以使用索引了。

9. SQL写大写
	我们在编写SQL的时候，官方推荐的是使用大写来写关键字，因为Oracle服务器总是先将小写字母转成大写后，才执行

10. 避免在索引列上使用NOT
	因为Oracle服务器遇到NOT后，他就会停止目前的工作，转而执行全表扫描

11. 避免在索引列上使用计算
	WHERE子句中，如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢

12. `>=` 替代 `>`
```
低效：
SELECT * FROM EMP WHERE DEPTNO > 3   
首先定位到DEPTNO=3的记录并且扫描到第一个DEPT大于3的记录
高效：
SELECT * FROM EMP WHERE DEPTNO >= 4  
直接跳到第一个DEPT等于4的记录
```

13. 用IN替代OR
```
select * from emp where sal = 1500 or sal = 3000 or sal = 800;
select * from emp where sal in (1500,3000,800);
```

14. 总是使用索引的第一个列
	如果索引是建立在多个列上，只有在它的第一个列被WHERE子句引用时，优化器才会选择使用该索引。 当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引
	```
	create index emp_sal_job_idex
	on emp(sal,job);
	----------------------------------
	select *
	from emp  
	where job != 'SALES';    
	``` 