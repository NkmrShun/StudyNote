# Redis 运用问题 #
## 一、缓存雪崩 ##
1.1 发生缓存雪崩的原因
因为Redis的原因导致大量请求直接到数据库。可能导致数据库垮掉，导致系统瘫痪。
	一般有两种情况：
	- Redis挂了，导致请求全部走数据库。
	- 大量相同过期时间的数据同时过期，导致某段时间内缓存失效，大量请求直接走数据库。

1.2 如何解决缓存雪崩
	1. Redis崩溃导致的缓存雪崩：
		- 事发前：实现Redis的高可用
		- 事发时：设置本地缓存+限流，尽量避免数据库崩溃（保证系统运行状态）
		- 事发后：Redis持久化，重启后自动从磁盘上加载数据，快速回复缓存数据。
	2. 缓存同时失效导致的缓存雪崩：
		缓存的时候给过期时间加一个随机值，可以大幅度减少缓存同一时间过期的情况


## 二、缓存穿透 ##
2.1 什么是缓存穿透
	请求查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。
		- 请求的数据在缓存大量不命中，导致请求走数据库。

2.2 如何解决缓存穿透
	- 由于请求的参数是不合法的(每次都请求不存在的参数),可以对参数进行过滤拦截，不合法就不让这个请求到数据库层。
	- 当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。
		- 这种情况我们一般会将空对象设置一个较短的过期时间。

## 三、缓存与数据库双写一致 ##
### 对于更新操作 ###
一般来说，执行更新操作时，我们会有两种选择：
	- 先操作数据库，再操作缓存
	- 先操作缓存，再操作数据库

首先，要明确的是，无论我们选择哪个，我们都希望这两个操作要么同时成功，要么同时失败。所以，这会演变成一个分布式事务的问题。

### 操作缓存 ###
操作缓存也有两种方案：
	- 更新缓存
	- 删除缓存

一般我们都是采取删除缓存缓存策略的，原因如下：
	1. 并发环境下，无论是先操作数据库还是后操作数据库而言，如果加上更新缓存，那就更加容易导致数据库与缓存数据不一致问题。(删除缓存直接和简单很多)
	2. 如果每次更新了数据库，都要更新缓存【这里指的是频繁更新的场景，这会耗费一定的性能】，倒不如直接删除掉。等再次读取时，缓存里没有，那我到数据库找，在数据库找到再写到缓存里边(体现懒加载)

基于这两点，对于缓存在更新时而言，都是建议执行删除操作！

### 先更新数据库，再删除缓存 ###
正常的情况是这样的：
- 先操作数据库，成功。
- 再删除缓存，也成功。

如果原子性被破坏了：
- 第一步成功(操作数据库)，第二步失败(删除缓存)，会导致数据库里是新数据，而缓存里是旧数据。
- 如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。

如果在高并发的场景下，出现数据库与缓存数据不一致的概率特别低，也不是没有：
- 缓存刚好失效
- 线程A查询数据库，得一个旧值
- 线程B将新值写入数据库
- 线程B删除缓存
- 线程A将查到的旧值写入缓存

要达成上述情况，还是说一句概率特别低：
	- 因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。

删除缓存失败的解决思路：
- 将需要删除的key发送到消息队列中
- 自己消费消息，获得需要删除的key
- 不断重试删除操作，直到成功

### 先删除缓存，再更新数据库 ###
正常情况是这样的：
- 先删除缓存，成功；
- 再更新数据库，也成功；

如果原子性被破坏了：
- 第一步成功(删除缓存)，第二步失败(更新数据库)，数据库和缓存的数据还是一致的。
- 如果第一步(删除缓存)就失败了，我们可以直接返回错误(Exception)，数据库和缓存的数据还是一致的。

高并发场景下
- 线程A删除了缓存
- 线程B查询，发现缓存已不存在
- 线程B去数据库查询得到旧值
- 线程B将旧值写入缓存
- 线程A将新值写入数据库

高并发下解决数据库与缓存不一致的思路：
- 将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。

### 对比两种策略 ###
我们可以发现，两种策略各自有优缺点：
- 先删除缓存，再更新数据库
	- 在高并发下表现不如意，在原子性被破坏时表现优异
- 先更新数据库，再删除缓存(Cache Aside Pattern设计模式)
	- 在高并发下表现优异，在原子性被破坏时表现不如意